//=============================================================================
//
// プレイヤー処理 [player.h]
// Author : 相馬靜雅
//
//=============================================================================
#include "main.h"
#include "player.h"
#include "input.h"
#include "camera.h"
#include "model.h"
#include "enemy.h"
#include "meshwall.h"
#include "game.h"
#include "edit.h"
#include "tutorial.h"
#include "impactwave.h"
#include "calculation.h"
#include "dispatch.h"
#include "cutepillow.h"
#include "shadow.h"
#include "meshorbit.h"
#include "mob.h"
#include "minimap_icon.h"
#include "particle.h"
#include "debugproc.h"
#include "serif.h"

//マクロ定義
#define MOVE		(0.9f)
#define DMG_TIME	(10)	//ダメージ状態の時間
#define ULT_WAIT	(100)	//待ち状態
#define PLAYER_TXT	"data\\TEXT\\motion_set_player.txt"

//プロトタイプ宣言
void ControllPlayer(void);
void ReadSetPlayer(void);
void ReadSetMotionPlayer(void);
void UpdateMotionPlayer(void);
void LimitPosPlayer(void);
void CollisionCharPlayer(void);
void CollisionWallPlayer(void);
void UpdateStatePlayer(void);
void UpdateATKGun(void);
void UpdateATKPenLight(void);
void CollisionATKPlayer(float fDistance, float fRadius);
void CalFormationPosPlayer(void);

void ControllTutorialPlayer(void);

//グローバル変数宣言
Player g_aPlayer;		//プレイヤーの情報
MotionData g_aMotionData[MAX_MOTION];		//モーション用の情報
int g_aaaaa;
int g_bbbbb;

//==================================================================================
//プレイヤーの初期化処理
//==================================================================================
void InitPlayer(void)
{

	//カメラの情報取得
	Camera *pCamera = GetCamera();

	//デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = GetDevice();

	for (int nCntMotion = 0; nCntMotion < MAX_MOTION; nCntMotion++)
	{//モーションの数繰り返す

		g_aMotionData[nCntMotion].bUse = false;	//使用しているか
		g_aMotionData[nCntMotion].nLoop = MOTION_LOOP_ON;	//ループ判定
		g_aMotionData[nCntMotion].nNumKey = 0;				//キーの数

		for (int nCntKey = 0; nCntKey < MAX_KEY; nCntKey++)
		{//キーの数繰り返す

			g_aMotionData[nCntMotion].aKey[nCntKey].nFrame = 0;	//再生フレーム

			for (int nCntParts = 0; nCntParts < MAX_PARTS; nCntParts++)
			{//パーツの数繰り返す

				g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);		//位置
				g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].posDest = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	//目標の位置
				g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].posDiff = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	//位置の差分
				g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);		//向き
				g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].rotDest = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	//目標の向き
				g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].rotDiff = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	//向きの差分
			}
		}
	}

	//各要素初期化
	if (GetMode() == MODE_GAME)
	{
		g_aPlayer.pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
		g_aPlayer.rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	}
	else
	{
		g_aPlayer.pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
		g_aPlayer.rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	}

	g_aPlayer.posOld = g_aPlayer.pos;
	g_aPlayer.move = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

	//隊列情報の初期化
	for (int nCntPos = 0; nCntPos < MAX_CROWD; nCntPos++)
	{
		g_aPlayer.aFormation[nCntPos].pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
		g_aPlayer.aFormation[nCntPos].nIndex = -1;
		g_aPlayer.aFormation[nCntPos].bUse = false;
	}
	g_aPlayer.fRotDest = g_aPlayer.rot.y;
	g_aPlayer.fRotDiff = 0.0f;
	g_aPlayer.nIdxShadow = -1;	//影のインデックス番号
	g_aPlayer.nIdxHPGauge = -1;	//催眠度ゲージのインデックス番号
	g_aPlayer.nIdxIcon = -1;	//ミニマップアイコンのインデックス番号
	g_aPlayer.nMaxLife = g_aPlayer.nLife;
	g_aPlayer.nState = PLAYERSTATE_NONE;	//状態
	g_aPlayer.nCntState = 0;				//状態カウント
	g_aPlayer.nCntWalk = 0;
	g_aPlayer.nCntDis = 0;
	g_aPlayer.nCntReturn = 0;
	g_aPlayer.nNowMotionNum = -1;
	g_aPlayer.nPatternKey = 0;			//今、何個目のキーか
	g_aPlayer.bUse = true;	//使用している状況にする
	g_aPlayer.bDisp = true;	//使用している状況にする
	g_aPlayer.bJump = false;
	g_aPlayer.bATK = false;
	g_aPlayer.BeforebUlt = false;
	g_aPlayer.bJump = false;
	g_aPlayer.bLand = true;
	g_aPlayer.bUseGun = false;
	g_aPlayer.bUseWoodStick = false;
	g_aPlayer.bUseStoneThrow = false;
	g_aPlayer.nIdxGun = -1;
	g_aPlayer.nIdxWoodStick = -1;
	g_aPlayer.nIdxStoneThrow = -1;
	g_aPlayer.nGunLife = 0;
	g_aPlayer.nStoneLife = 0;
	g_aPlayer.bMove = false;
	g_aPlayer.bUlt = false;
	g_aPlayer.nNumGetParts = 0;
	g_aPlayer.nWaitUltTime = 0;		//ウルト出現の待ち時間
	g_aPlayer.nPartsNum = 0;
	g_aPlayer.fRadius = 50.0f;	//半径

	for (int nCount = 0; nCount < MAX_PLAYER; nCount++)
	{
		g_aPlayer.aModel[nCount].pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
		g_aPlayer.aModel[nCount].rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
		g_aPlayer.aModel[nCount].nType = -1;	//NULL
		g_aPlayer.aModel[nCount].nParent = -1;	//NULL
		g_aPlayer.aModel[nCount].bUse = false;	//使用しているか
		g_aPlayer.aModel[nCount].posOrigin = g_aPlayer.aModel[nCount].pos;
	}


	//外部ファイル読み込み
	ReadSetPlayer();
	ReadSetMotionPlayer();

	//モーションの設定
	SetMotisonPlayer(PLAYERMOTION_DEF);
}

//==================================================================================
//プレイヤーの終了処理
//==================================================================================
void UninitPlayer(void)
{

	for (int nCount = 0; nCount < MAX_MODEL; nCount++)
	{
		for (int nCntTex = 0; nCntTex < MAX_TX; nCntTex++)
		{
			//テクスチャの破棄
			if (g_aPlayer.aModel[nCount].pTexture[nCntTex] != NULL)
			{
				g_aPlayer.aModel[nCount].pTexture[nCntTex]->Release();
				g_aPlayer.aModel[nCount].pTexture[nCntTex] = NULL;
			}
		}

		//メッシュの破棄
		if (g_aPlayer.aModel[nCount].pMesh != NULL)
		{
			g_aPlayer.aModel[nCount].pMesh->Release();
			g_aPlayer.aModel[nCount].pMesh = NULL;
		}

		//マテリアルの破棄
		if (g_aPlayer.aModel[nCount].pBuffMat != NULL)
		{
			g_aPlayer.aModel[nCount].pBuffMat->Release();
			g_aPlayer.aModel[nCount].pBuffMat = NULL;
		}
	}

}

//==================================================================================
//プレイヤーの更新処理
//==================================================================================
void UpdatePlayer(void)
{
	//カメラの情報取得
	Camera *pCamera = GetCamera();

	if (g_aPlayer.bUse == true)
	{//使用していたら

	 //過去の位置保存
		g_aPlayer.posOld = g_aPlayer.pos;

		for (int nCntParts = 0; nCntParts < g_aPlayer.nPartsNum; nCntParts++)
		{//パーツ分繰り返す

		 //パーツごとのマトリックス取得
			D3DXMATRIX mtxParts = GetParentMatrix(nCntParts);

			g_aPlayer.aModel[nCntParts].OldmtxWorld = mtxParts;
		}


		//プレイヤーの操作
		ControllPlayer();

		//隊列の位置更新
		CalFormationPosPlayer();

		//攻撃処理
		UpdateATKGun();
		UpdateATKPenLight();

		SetPositionSerif(g_aPlayer.nIdxSerif, g_aPlayer.pos);

		if (g_aPlayer.bMove == true && g_aPlayer.bJump == false)
		{//移動してるとき

			g_aPlayer.nCntWalk++;	//カウント加算

			if (g_aPlayer.nCntWalk > 24)
			{
				g_aPlayer.nCntWalk = 0;

				//歩行パーティクルの設定
				SetParticle(g_aPlayer.pos, PARTICLE_TYPE_WALK);
			}


			if (g_aPlayer.nNowMotionNum != PLAYERMOTION_WALK)
			{
				//モーションの設定
				SetMotisonPlayer(PLAYERMOTION_WALK);
			}

		}
		else if (g_aPlayer.bJump == true)
		{//ジャンプしている

			if (g_aPlayer.nNowMotionNum != PLAYERMOTION_JUMP)
			{
				//モーションの設定
				SetMotisonPlayer(PLAYERMOTION_JUMP);
			}
		}
		else if (g_aPlayer.bATK == true)
		{//攻撃してるとき

			if (g_aPlayer.nNowMotionNum != PLAYERMOTION_ACTION)
			{
				//モーションの設定
				SetMotisonPlayer(PLAYERMOTION_ACTION);
			}
		}
		else
		{//ニュートラルモーション

			if (g_aPlayer.nNowMotionNum != PLAYERMOTION_DEF &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_ACTION &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_DISPATCHL &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_DISPATCHR &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_RETURNL &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_RETURNR)
			{
				//攻撃状態解除
				g_aPlayer.bATK = false;

				//モーションの設定
				SetMotisonPlayer(PLAYERMOTION_DEF);
			}
		}

		//軌跡の情報取得
		ORBIT *pOrbit = GetMeshOrbit();

		//パーツごとのマトリックス取得
		D3DXMATRIX mtxParts = GetParentMatrix(10);

		pOrbit->pMtxparent = &mtxParts;

		//モーションの更新
		UpdateMotionPlayer();

		//キャラクターとの当たり判定
		CollisionCharPlayer();

		//壁との当たり判定
		//CollisionWall(&g_aPlayer.pos, g_aPlayer.posOld);

		//座標制限
		LimitPosPlayer();

		//影の位置更新
		SetPositionShadow(g_aPlayer.nIdxShadow, g_aPlayer.pos);

		//アイコンの位置更新
		UpdatePositionIcon(g_aPlayer.nIdxIcon, g_aPlayer.pos);

	}

	//状態更新
	UpdateStatePlayer();

}

//==================================================================================
//モデルの操作
//==================================================================================
void ControllPlayer(void)
{
	//カメラの情報取得
	Camera *pCamera = GetCamera();

	//エディットの情報取得
	Edit  *pEdit = GetEdit();

	//ターゲットの情報取得
	DISPATCH *pDispatch = GetDispatch();

	if (GetGameState() == GAMESTATE_NONE && pDispatch->bUse == false && pEdit->bUse == false)
	{//ターゲット中以外

		if (g_aPlayer.bATK == false && 
			g_aPlayer.nNowMotionNum != PLAYERMOTION_DISPATCHL &&
			g_aPlayer.nNowMotionNum != PLAYERMOTION_DISPATCHR &&
			g_aPlayer.nNowMotionNum != PLAYERMOTION_RETURNL &&
			g_aPlayer.nNowMotionNum != PLAYERMOTION_RETURNR)
		{//ガン発動中は強制キャンセル

			if (GetKeyboardPress(DIK_A) == true || XGetStickPressL(BUTTON_LX, 0) < 0)
			{//←キーが押された,左移動

				if (GetKeyboardPress(DIK_W) == true || YGetStickPressL(BUTTON_LY, 0) > 0)
				{//A+W,左上移動

					g_aPlayer.move.x += sinf(-D3DX_PI * MOVE_LRDW + pCamera->rot.y) * MOVE;
					g_aPlayer.move.z += cosf(-D3DX_PI * MOVE_LRDW + pCamera->rot.y) * MOVE;
					g_aPlayer.fRotDest = D3DX_PI * MOVE_LRUP + pCamera->rot.y;
				}
				else if (GetKeyboardPress(DIK_S) == true || YGetStickPressL(BUTTON_LY, 0) < 0)
				{//A+S,左下移動

					g_aPlayer.move.x += sinf(-D3DX_PI * MOVE_LRUP + pCamera->rot.y) * MOVE;
					g_aPlayer.move.z += cosf(-D3DX_PI * MOVE_LRUP + pCamera->rot.y) * MOVE;
					g_aPlayer.fRotDest = D3DX_PI * MOVE_LRDW + pCamera->rot.y;
				}
				else
				{//A,左移動

					g_aPlayer.move.x += sinf(-D3DX_PI * MOVE_LR + pCamera->rot.y) * MOVE;
					g_aPlayer.move.z += cosf(-D3DX_PI * MOVE_LR + pCamera->rot.y) * MOVE;
					g_aPlayer.fRotDest = D3DX_PI * MOVE_LR + pCamera->rot.y;
				}

				g_aPlayer.bMove = true;
			}
			else if (GetKeyboardPress(DIK_D) == true || XGetStickPressL(BUTTON_LX, 0) > 0)
			{//Dキーが押された,右移動

				if (GetKeyboardPress(DIK_W) == true || YGetStickPressL(BUTTON_LY, 0) > 0)
				{//D+W,右上移動

					g_aPlayer.move.x += sinf(D3DX_PI * MOVE_LRDW + pCamera->rot.y) * MOVE;
					g_aPlayer.move.z += cosf(D3DX_PI * MOVE_LRDW + pCamera->rot.y) * MOVE;
					g_aPlayer.fRotDest = -D3DX_PI * MOVE_LRUP + pCamera->rot.y;
				}
				else if (GetKeyboardPress(DIK_S) == true || YGetStickPressL(BUTTON_LY, 0) < 0)
				{//D+S,右下移動

					g_aPlayer.move.x += sinf(D3DX_PI * MOVE_LRUP + pCamera->rot.y) * MOVE;
					g_aPlayer.move.z += cosf(D3DX_PI * MOVE_LRUP + pCamera->rot.y) * MOVE;
					g_aPlayer.fRotDest = -D3DX_PI * MOVE_LRDW + pCamera->rot.y;
				}
				else
				{//D,右移動

					g_aPlayer.move.x += sinf(D3DX_PI * MOVE_LR + pCamera->rot.y) * MOVE;
					g_aPlayer.move.z += cosf(D3DX_PI * MOVE_LR + pCamera->rot.y) * MOVE;
					g_aPlayer.fRotDest = -D3DX_PI * MOVE_LR + pCamera->rot.y;
				}

				g_aPlayer.bMove = true;
			}
			else if (GetKeyboardPress(DIK_W) == true || YGetStickPressL(BUTTON_LY, 0) > 0)
			{//Wが押された、奥移動

				g_aPlayer.move.x += sinf(pCamera->rot.y) * MOVE;
				g_aPlayer.move.z += cosf(pCamera->rot.y) * MOVE;
				g_aPlayer.fRotDest = D3DX_PI + pCamera->rot.y;
				g_aPlayer.bMove = true;
			}
			else if (GetKeyboardPress(DIK_S) == true || YGetStickPressL(BUTTON_LY, 0) < 0)
			{//Sが押された、手前移動

				g_aPlayer.move.x += sinf(D3DX_PI + pCamera->rot.y) * MOVE;
				g_aPlayer.move.z += cosf(D3DX_PI + pCamera->rot.y) * MOVE;
				g_aPlayer.fRotDest = pCamera->rot.y;
				g_aPlayer.bMove = true;
			}
			else
			{//なんのキーも押されていない

				if (g_aPlayer.move.x <= 1.0f && g_aPlayer.move.x >= -1.0f ||
					g_aPlayer.move.z <= 1.0f && g_aPlayer.move.z >= -1.0f)
				{
					g_aPlayer.bMove = false;
				}
			}
		}


		if (g_aPlayer.bATK == false && g_aPlayer.bJump == false && GetKeyboardTrigger(DIK_RETURN) == true ||
			g_aPlayer.bATK == false && g_aPlayer.bJump == false && GetGamepadTrigger(BUTTON_B, 0))
		{//ENTERが押された,,弾発射

			//抱き枕の設定処理
			SetCutepillow(g_aPlayer.pos, g_aPlayer.rot, PILLOWPARENT_PLAYER);
		}

		if (g_aPlayer.bJump == false && GetKeyboardTrigger(DIK_L) == true)
		{//Lが押された

			g_aPlayer.bATK = true;
			g_aPlayer.bMove = false;
			g_aPlayer.move.x = 0.0f;
			g_aPlayer.move.z = 0.0f;
		}
	}

	if (GetGamepadTrigger(BUTTON_RB, 0) || GetKeyboardTrigger(DIK_RSHIFT) == true)
	{//派遣の使用状況入れ替え

 		SetRightDisPatch();
	}
	if (GetGamepadTrigger(BUTTON_LB, 0) || GetKeyboardTrigger(DIK_LSHIFT) == true)
	{//派遣の使用状況入れ替え

		SetLeftDisPatch();
	}

	//現在と目標の差分を求める
	g_aPlayer.fRotDiff = g_aPlayer.fRotDest - g_aPlayer.rot.y;

	//角度の正規化
	g_aPlayer.fRotDiff = RotNormalize(g_aPlayer.fRotDiff);

	//角度の補正をする
	g_aPlayer.rot.y += g_aPlayer.fRotDiff * 0.1f;

	//角度の正規化
	g_aPlayer.rot.y = RotNormalize(g_aPlayer.rot.y);

	//重力処理
	g_aPlayer.move.y -= 1.0f;

	//位置更新
	g_aPlayer.pos += g_aPlayer.move;

	//慣性つける
	g_aPlayer.move.x += (0.0f - g_aPlayer.move.x) * 0.15f;
	g_aPlayer.move.z += (0.0f - g_aPlayer.move.z) * 0.15f;

	PrintDebugProc(
		"\n------プレイヤーの操作------\n"
		"<移動> W/A/S/D\n"
		"<催眠> L\n"
		"<派遣> LT/RT\n"
		"<抱き枕> ENTER\n\n");

}

//==================================================================================
//プレイヤーの座標制限
//==================================================================================
void LimitPosPlayer(void)
{
	if (g_aPlayer.pos.y < 0.0f && g_aPlayer.bUlt == false)
	{//地面より下に行ったら

		g_aPlayer.pos.y = 0.0f;

		//重力処理
		g_aPlayer.move.y = 0.0f;

		g_aPlayer.bJump = false;
		g_aPlayer.bLand = true;
	}

	//移動制限
	if (g_aPlayer.pos.x - g_aPlayer.fRadius <= -LIMIT_POS && g_aPlayer.posOld.x - g_aPlayer.fRadius >= -LIMIT_POS)
	{//今回が-1000以下, 前回が-1000以上

		g_aPlayer.pos.x = -LIMIT_POS + g_aPlayer.fRadius;
	}
	if (g_aPlayer.pos.x + g_aPlayer.fRadius >= LIMIT_POS && g_aPlayer.posOld.x + g_aPlayer.fRadius <= LIMIT_POS)
	{//今回が1000以上, 前回が1000以下

		g_aPlayer.pos.x = LIMIT_POS - g_aPlayer.fRadius;
	}
	if (g_aPlayer.pos.z + g_aPlayer.fRadius >= LIMIT_POS && g_aPlayer.posOld.z + g_aPlayer.fRadius <= LIMIT_POS)
	{//今回が1000以上, 前回が1000以下

		g_aPlayer.pos.z = LIMIT_POS - g_aPlayer.fRadius;
	}
	if (g_aPlayer.pos.z - g_aPlayer.fRadius <= -LIMIT_POS && g_aPlayer.posOld.z - g_aPlayer.fRadius >= -LIMIT_POS)
	{//今回が-1000以下, 前回が-1000以上

		g_aPlayer.pos.z = -LIMIT_POS + g_aPlayer.fRadius;
	}

}

//==================================================================================
//プレイヤーの隊列計算処理
//==================================================================================
void CalFormationPosPlayer(void)
{
	for (int nCntCrowd = 0, nCntformation = 0; nCntCrowd < MAX_CROWD; nCntformation++)
	{
		//横の人数
		int nWidth = 2 + nCntCrowd;

		//横の人数分繰り返し
		for (int nCntWidth = 0; nCntWidth < nWidth; nCntWidth++)
		{
			//向きの設定
			float fRotWidth = 2.0f / (float)(nWidth - 1);
			float fRot = fRotWidth * nCntWidth + (D3DX_PI * MOVE_LRDW);

			if (nCntCrowd + nCntWidth < MAX_CROWD)
			{//最大値以下

				g_aPlayer.aFormation[nCntCrowd + nCntWidth].pos =
					D3DXVECTOR3
					(
						g_aPlayer.pos.x + sinf(-D3DX_PI * MOVE_LR + fRot + g_aPlayer.rot.y) * (FORMATION_DISTANCE * (nCntformation + 1)),
						0.0f,
						g_aPlayer.pos.z + cosf(-D3DX_PI * MOVE_LR + fRot + g_aPlayer.rot.y) * (FORMATION_DISTANCE * (nCntformation + 1)));
			}
			else
			{
				break;
			}
		}

		nCntCrowd += (nWidth - 1);
	}
}

//==================================================================================
//プレイヤーの隊列計算処理
//==================================================================================
int SetFormationPosPlayer(void)
{
	int nCntIdx = 0;

	for (int nCntCrowd = 0; nCntCrowd < MAX_CROWD; nCntCrowd++)
	{
		if (g_aPlayer.aFormation[nCntCrowd].bUse == false)
		{//使用していなかったら

			//インデックス番号を代入
			nCntIdx = nCntCrowd;

			g_aPlayer.aFormation[nCntCrowd].bUse = true;
			break;
		}
	}

	return nCntIdx;
}

//==================================================================================
//ガンの攻撃更新処理
//==================================================================================
void UpdateATKGun(void)
{
	//カメラの情報取得
	Camera *pCamera = GetCamera();

	static int nCnt = 0;

	if (g_aPlayer.bATK == true)
	{//ガン発動中

		nCnt++;

		if (nCnt % 5 == 0 && nCnt <= 15)
		{
		}

		if (GetKeyboardPress(DIK_A) == true || XGetStickPressL(BUTTON_LX, 0) < 0)
		{//←キーが押された,左移動

			if (GetKeyboardPress(DIK_W) == true || YGetStickPressL(BUTTON_LY, 0) > 0)
			{//A+W,左上移動

				g_aPlayer.fRotDest = D3DX_PI * MOVE_LRUP + pCamera->rot.y;
			}
			else if (GetKeyboardPress(DIK_S) == true || YGetStickPressL(BUTTON_LY, 0) < 0)
			{//A+S,左下移動

				g_aPlayer.fRotDest = D3DX_PI * MOVE_LRDW + pCamera->rot.y;
			}
			else
			{//A,左移動

				g_aPlayer.fRotDest = D3DX_PI * MOVE_LR + pCamera->rot.y;
			}
		}
		else if (GetKeyboardPress(DIK_D) == true || XGetStickPressL(BUTTON_LX, 0) > 0)
		{//Dキーが押された,右移動

			if (GetKeyboardPress(DIK_W) == true || YGetStickPressL(BUTTON_LY, 0) > 0)
			{//D+W,右上移動

				g_aPlayer.fRotDest = -D3DX_PI * MOVE_LRUP + pCamera->rot.y;
			}
			else if (GetKeyboardPress(DIK_S) == true || YGetStickPressL(BUTTON_LY, 0) < 0)
			{//D+S,右下移動

				g_aPlayer.fRotDest = -D3DX_PI * MOVE_LRDW + pCamera->rot.y;
			}
			else
			{//D,右移動

				g_aPlayer.fRotDest = -D3DX_PI * MOVE_LR + pCamera->rot.y;
			}
		}
		else if (GetKeyboardPress(DIK_W) == true || YGetStickPressL(BUTTON_LY, 0) > 0)
		{//Wが押された、奥移動

			g_aPlayer.fRotDest = D3DX_PI + pCamera->rot.y;
		}
		else if (GetKeyboardPress(DIK_S) == true || YGetStickPressL(BUTTON_LY, 0) < 0)
		{//Sが押された、手前移動

			g_aPlayer.fRotDest = pCamera->rot.y;
		}
	}
	else
	{
		nCnt = 0;
	}
}

//==================================================================================
//攻撃処理
//==================================================================================
void UpdateATKPenLight(void)
{
	switch (g_aPlayer.nNowMotionNum)
	{
	case PLAYERMOTION_ACTION:

		//パーツごとのマトリックス取得
		D3DXMATRIX mtxParts = GetParentMatrix(PLAYERPARTS_WOODSTICK);

		//攻撃の当たり判定
		CollisionATKPlayer(PENLIGHT_RADIUS, PENLIGHT_RADIUS);
		break;
	}
}

//==================================================================================
//プレイヤーの攻撃
//==================================================================================
void CollisionATKPlayer(float fDistance, float fRadius)
{
	//モブの情報取得
	Mob *pMob = GetMob();

	//ペンライトの攻撃
	for (int nCntMob = 0; nCntMob < MAX_MOB; nCntMob++, pMob++)
	{
		if (pMob->aModel.bUse == true && pMob->aModel.nState != MOBSTATE_APPIEAR)
		{//モブが使用されていたら

			float fLength = pMob->aModel.vtxMax.x + fRadius;

			//ペンライトの当たり判定
			bool bPenLight = CollisionFan(g_aPlayer.pos,
				D3DXVECTOR3(g_aPlayer.pos.x + sinf(D3DX_PI * 0.25f + g_aPlayer.rot.y) * -fDistance, g_aPlayer.pos.y, g_aPlayer.pos.z + cosf(D3DX_PI * 0.25f + g_aPlayer.rot.y) * -fDistance),
				D3DXVECTOR3(g_aPlayer.pos.x + sinf(-D3DX_PI * 0.25f + g_aPlayer.rot.y) * -fDistance, g_aPlayer.pos.y, g_aPlayer.pos.z + cosf(-D3DX_PI * 0.25f + g_aPlayer.rot.y) * -fDistance),
				pMob->aModel.pos, pMob->aModel.posOld);

			if (bPenLight == true)
			{//扇の範囲に入ったら

			 //催眠度が減少するまでのカウンターを初期化
				pMob->nSubHypCounter = HYP_CNTTIME;

				//モブのヒット処理
				HitMob(nCntMob);
			}
		}
	}
}

//==================================================================================
//壁との当たり判定
//==================================================================================
void CollisionWallPlayer(void)
{
	//壁の情報取得
	MESHWALL *pMeshWall = GetMeshWall();

	for (int nCntWall = 0; nCntWall < MAX_WALL; nCntWall++, pMeshWall++)
	{//壁の数分繰り返す

		if (pMeshWall->bUse == true)
		{//壁が使用されているとき

		 //壁の幅
			float fLen = (pMeshWall->nWidth * POS_MESHWALL) * 0.5f;

			//左の頂点座標
			D3DXVECTOR3 pos0 = D3DXVECTOR3(
				pMeshWall->pos.x + sinf(pMeshWall->rot.y + D3DX_PI * MOVE_LR) * -fLen,
				g_aPlayer.pos.y,
				pMeshWall->pos.z + cosf(pMeshWall->rot.y + D3DX_PI * MOVE_LR) * -fLen);

			//右の頂点座標
			D3DXVECTOR3 pos1 = D3DXVECTOR3(
				pMeshWall->pos.x + sinf(pMeshWall->rot.y + D3DX_PI * MOVE_LR) * fLen,
				g_aPlayer.pos.y,
				pMeshWall->pos.z + cosf(pMeshWall->rot.y + D3DX_PI * MOVE_LR) * fLen);

			//境界線のベクトル
			D3DXVECTOR3 vecLine;
			vecLine.x = pos1.x - pos0.x;
			vecLine.z = pos1.z - pos0.z;

			//プレイヤーの境界線のベクトル
			D3DXVECTOR3 vecLinePlayer;
			vecLinePlayer.x = g_aPlayer.pos.x - g_aPlayer.posOld.x;
			vecLinePlayer.z = g_aPlayer.pos.z - g_aPlayer.posOld.z;

			//プレイヤーと壁のベクトル
			D3DXVECTOR3 vecToPosPlayer;
			vecToPosPlayer.x = pos1.x - g_aPlayer.posOld.x;
			vecToPosPlayer.z = pos1.z - g_aPlayer.posOld.z;

			//面積の最大値
			float fMaxAreaPlayer = (vecLinePlayer.z * vecLine.x) - (vecLinePlayer.x * vecLine.z);

			//今回の面積
			float fNowAreaPlayer = (vecToPosPlayer.z * vecLine.x) - (vecToPosPlayer.x * vecLine.z);

			//割合
			float fRatePlayer = fNowAreaPlayer / fMaxAreaPlayer;

			if (fRatePlayer >= 0.0f && fRatePlayer <= 1.0f)
			{//面積の範囲内にいたら判定

				if ((vecLinePlayer.z * vecToPosPlayer.x) - (vecLinePlayer.x * vecToPosPlayer.z) > 0)
				{//壁に当たったら

					//交点からはみ出た分
					D3DXVECTOR3 CollisionPointPlayer = D3DXVECTOR3(0.0f, g_aPlayer.pos.y, 0.0f);
					CollisionPointPlayer.x = (g_aPlayer.pos.x + (vecLinePlayer.x * (fRatePlayer - 1.0f)));
					CollisionPointPlayer.z = (g_aPlayer.pos.z + (vecLinePlayer.z * (fRatePlayer - 1.0f)));

					//法線ベクトル(境界線ベクトルのXとZ反転)
					D3DXVECTOR3 vecNor = D3DXVECTOR3(vecLine.z, 0.0f, -vecLine.x);

					//ベクトルの正規化
					D3DXVec3Normalize(&vecNor, &vecNor);

					//プレイヤーの逆移動量
					D3DXVECTOR3 PlayerInverceMove;
					PlayerInverceMove.z = vecLinePlayer.z * (fRatePlayer - 1.0f);
					PlayerInverceMove.x = vecLinePlayer.x * (fRatePlayer - 1.0f);

					//内積(壁の法線とプレイヤーの逆移動量)
					float fDot = (PlayerInverceMove.x * vecNor.x) + (PlayerInverceMove.z * vecNor.z);

					//壁ずり移動量
					D3DXVECTOR3 MoveWall = vecNor * fDot;

					D3DXVECTOR3 ppp = (CollisionPointPlayer - g_aPlayer.pos);
					D3DXVECTOR3 pppp = ppp + MoveWall;

					//ぶつかった点に補正
					g_aPlayer.pos += MoveWall + (vecNor * 0.1f);

				}

			}

		}

	}
}

//==================================================================================
//弾のヒット処理
//==================================================================================
void HitPlayer(D3DXVECTOR3 move, int nDMG)
{

	//エディットの情報取得
	Edit *pEdit = GetEdit();

	if (g_aPlayer.bUlt == false && g_aPlayer.bUse == true && g_aPlayer.nState == PLAYERSTATE_NONE && pEdit->bUse == false)
	{//ウルト状態じゃないとき

		g_aPlayer.move = move;	//移動量加算
		g_aPlayer.nLife -= nDMG;	//体力減らす

		if (g_aPlayer.nLife <= 0)
		{//体力がなくなった

			g_aPlayer.nLife = 0;
			//g_aPlayer.bUse = false;
			g_aPlayer.move = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

			//サウンド停止
			SetGameState(GAMESTATE_END, 120);
		}
		else
		{//まだ体力が残ってる

			g_aPlayer.nCntState = DMG_TIME;	//ダメージ状態を保つ時間を与える

			for (int nCntParts = 0; nCntParts < g_aPlayer.nPartsNum; nCntParts++)
			{//パーツ分繰り返す

				D3DXMATERIAL *pMat;	//マテリアルデータへのポインタ

									//マテリアルデータへのポインタを取得
				pMat = (D3DXMATERIAL*)g_aPlayer.aModel[nCntParts].pBuffMat->GetBufferPointer();

				//頂点数分繰り返し
				for (int nCntMat = 0; nCntMat < (int)g_aPlayer.aModel[nCntParts].dwNumMat; nCntMat++)
				{//マテリアルを赤くする

					pMat[nCntMat].MatD3D.Diffuse = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f);
					pMat[nCntMat].MatD3D.Ambient = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f);
				}
			}
		}
	}
}


//==================================================================================
//プレイヤーの状態更新
//==================================================================================
void UpdateStatePlayer(void)
{

	//カメラの情報取得
	Camera *pCamera = GetCamera();



	D3DXMATERIAL *pMat;	//マテリアルデータへのポインタ

	switch (g_aPlayer.nState)
	{
	case PLAYERSTATE_NONE:

		for (int nCntParts = 0; nCntParts < g_aPlayer.nPartsNum; nCntParts++)
		{//パーツ分繰り返す

		 //マテリアルデータへのポインタを取得
			pMat = (D3DXMATERIAL*)g_aPlayer.aModel[nCntParts].pBuffMat->GetBufferPointer();

			//頂点数分繰り返し
			for (int nCntMat = 0; nCntMat < (int)g_aPlayer.aModel[nCntParts].dwNumMat; nCntMat++)
			{
				//元の色に戻す
				pMat[nCntMat].MatD3D.Diffuse = g_aPlayer.aModel[nCntParts].pMatData[nCntMat].MatD3D.Diffuse;
				pMat[nCntMat].MatD3D.Ambient = g_aPlayer.aModel[nCntParts].pMatData[nCntMat].MatD3D.Ambient;
			}
		}
		break;
	}
}

//==================================================================================
//キャラクターとの当たり判定
//==================================================================================
void CollisionCharPlayer(void)
{
	//敵の情報取得
	Enemy *pEnemy = GetEnemy();

	for (int nCntEnemy = 0; nCntEnemy < MAX_ENEMY; nCntEnemy++, pEnemy++)
	{
		if (pEnemy->bUse == true && pEnemy->bMoreSpawn == true)
		{//敵が使用されていたら

		 //キャラクター同士の当たり判定
			CollisionCharacter(
				&g_aPlayer.pos, &g_aPlayer.posOld, D3DXVECTOR3(g_aPlayer.fRadius, 0.0f, g_aPlayer.fRadius), D3DXVECTOR3(-g_aPlayer.fRadius, 0.0f, -g_aPlayer.fRadius),
				&pEnemy->pos, D3DXVECTOR3(pEnemy->fRadius, 0.0f, pEnemy->fRadius), D3DXVECTOR3(-pEnemy->fRadius, 0.0f, -pEnemy->fRadius));
		}
	}


	//モデルの情報取得
	ModelModel *pModel = GetModel();

	for (int nCntModel = 0; nCntModel < MAX_MODEL; nCntModel++, pModel++)
	{
		if (pModel->bUse == true && pModel->nType < SMALL_NUM)
		{//モデルが使用されていたら

			//キャラクター同士の当たり判定
			CollisionCharacter(
				&g_aPlayer.pos, &g_aPlayer.posOld, D3DXVECTOR3(g_aPlayer.fRadius, 0.0f, g_aPlayer.fRadius), D3DXVECTOR3(-g_aPlayer.fRadius, 0.0f, -g_aPlayer.fRadius),
				&pModel->posOrigin, pModel->vtxMax, pModel->vtxMin);
		}
	}


	//モデルの情報取得
	Mob *pMob = GetMob();

	bool bRight = false, bLeft = false;

	D3DXVECTOR3 pppp = D3DXVECTOR3(
		g_aPlayer.pos.x + sinf(D3DX_PI * 0.25f + g_aPlayer.rot.y) * -300.0f,
		g_aPlayer.pos.y,
		g_aPlayer.pos.z + cosf(D3DX_PI * 0.25f + g_aPlayer.rot.y) * -300.0f);

	D3DXVECTOR3 ppp = D3DXVECTOR3(
		g_aPlayer.pos.x + sinf(-D3DX_PI * 0.25f + g_aPlayer.rot.y) * -300.0f,
		g_aPlayer.pos.y,
		g_aPlayer.pos.z + cosf(-D3DX_PI * 0.25f + g_aPlayer.rot.y) * -300.0f);

	SetPositionShadow(g_aaaaa, pppp);
	SetPositionShadow(g_bbbbb, ppp);

	for (int nCntMob = 0; nCntMob < MAX_MOB; nCntMob++, pMob++)
	{
		if (pMob->aModel.bUse == true)
		{//モデルが使用されていたら

		 ////キャラクター同士の当たり判定
		 //CollisionCharacter(
		 //	&g_aPlayer.pos, &g_aPlayer.posOld, D3DXVECTOR3(g_aPlayer.fRadius, 0.0f, g_aPlayer.fRadius), D3DXVECTOR3(-g_aPlayer.fRadius, 0.0f, -g_aPlayer.fRadius),
		 //	&pMob->aModel.posOrigin, pMob->aModel.vtxMax, pMob->aModel.vtxMin);


			bRight = CollisionFan(
				g_aPlayer.pos,
				D3DXVECTOR3(g_aPlayer.pos.x + sinf(D3DX_PI * 0.25f + g_aPlayer.rot.y) * -300.0f, g_aPlayer.pos.y, g_aPlayer.pos.z + cosf(D3DX_PI * 0.25f + g_aPlayer.rot.y) * -300.0f),
				D3DXVECTOR3(g_aPlayer.pos.x + sinf(-D3DX_PI * 0.25f + g_aPlayer.rot.y) * -300.0f, g_aPlayer.pos.y, g_aPlayer.pos.z + cosf(-D3DX_PI * 0.25f + g_aPlayer.rot.y) * -300.0f),
				pMob->aModel.pos,
				pMob->aModel.posOld);

			if (bRight == true)
			{

				PrintDebugProc("\nあたったあああああああああ\n");
				break;
			}
		}
	}
}

//==================================================================================
//プレイヤーのモーション処理
//==================================================================================
void SetMotisonPlayer(int nMotionType)
{

	//if (g_aPlayer.nNowMotionNum != nMotionType)
	//{

	//	for (int nCntKey = 0; nCntKey < g_aMotionData[nMotionType].nNumKey; nCntKey++)
	//	{//キー数分繰り返す

	//		for (int nCntParts = 0; nCntParts < g_aPlayer.nPartsNum; nCntParts++)
	//		{//パーツ分繰り返す

	//			g_aPlayer.aModel[nCntParts].rot = g_aMotionData[nMotionType].aKey[nCntKey].aParts[nCntParts].rot;
	//			g_aPlayer.aModel[nCntParts].pos = g_aPlayer.aModel[nCntParts].posOrigin;
	//		}

	//		g_aPlayer.nCntFrame = 0;	//フレームカウントリセット
	//	}

	//	//今のモーションの更新
	//	g_aPlayer.nNowMotionNum = nMotionType;

	//	g_aPlayer.nPatternKey = 0;	//現在のキー番号リセット
	//	g_aPlayer.nCntAllFrame = 0;	//総フレーム数リセット
	//}


	//for (int nCntParts = 0; nCntParts < g_aPlayer.nPartsNum; nCntParts++)
	//{//パーツ分繰り返す

	//	//元の向きと現在の向きで目標の向きを求める
	//	g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDest = g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rot;
	//	g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].posDest = g_aPlayer.aModel[nCntParts].posOrigin + g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].pos;

	//	//現在と目標の差分を求める
	//	g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDiff = g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDest - g_aPlayer.aModel[nCntParts].rot;
	//	g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].posDiff = g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].posDest - g_aPlayer.aModel[nCntParts].pos;

	//	//角度の正規化
	//	g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDiff.x = RotNormalize(g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDiff.x);
	//	g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDiff.y = RotNormalize(g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDiff.y);
	//	g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDiff.z = RotNormalize(g_aMotionData[nMotionType].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDiff.z);

	//}

	//今のモーションの更新
	g_aPlayer.nNowMotionNum = nMotionType;
	g_aPlayer.nPatternKey = 0;	//現在のキー番号リセット
	g_aPlayer.nCntFrame = 0;	//フレームカウントリセット
	g_aPlayer.nCntAllFrame = 0;	//総フレーム数リセット

}

//==================================================================================
//プレイヤーのモーション更新処理
//==================================================================================
void UpdateMotionPlayer(void)
{
	//カメラの情報取得
	Camera *pCamera = GetCamera();

	//for (int nCntParts = 0; nCntParts < g_aPlayer.nPartsNum; nCntParts++)
	//{//パーツ分繰り返す

	//	//差分を求めて規定フレームで終わるように補正
	//	g_aPlayer.aModel[nCntParts].rot +=
	//		g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rotDiff /	//目的と現在の差分
	//		(float)g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].nFrame;					//再生フレームで割る

	//	//位置
	//	g_aPlayer.aModel[nCntParts].pos +=
	//		g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].posDiff /	//目的と現在の差分
	//		(float)g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].nFrame;					//再生フレームで割る

	//	if (g_aPlayer.aModel[nCntParts].nParent == -1)
	//	{//親の場合

	//		//マトリックスの取得
	//		D3DXMATRIX mtxwood = GetParentMatrix(nCntParts);

	//		g_aPlayer.pos.x += 
	//			sinf(g_aPlayer.rot.y) * (g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].posDiff.z /	//目的と現在の差分
	//			(float)g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].nFrame);			//再生フレームで割る

	//		g_aPlayer.pos.z += 
	//			cosf(g_aPlayer.rot.y) * (g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].posDiff.z /	//目的と現在の差分
	//			(float)g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].nFrame);			//再生フレームで割る
	//	}

	//	//角度の正規化
	//	g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.x = RotNormalize(g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.x);
	//	g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.y = RotNormalize(g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.y);
	//	g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.z = RotNormalize(g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.z);

	//}

	////フレームのカウントを加算
	//g_aPlayer.nCntFrame++;
	//g_aPlayer.nCntAllFrame++;

	//if (g_aPlayer.nCntFrame >= g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].nFrame)
	//{//フレームのカウントがフレーム数に達したら

	//	//フレームのカウントをゼロに戻す
	//	g_aPlayer.nCntFrame = 0;

	//	//パターンNO.更新
	//	g_aPlayer.nPatternKey = (g_aPlayer.nPatternKey + 1) % g_aMotionData[g_aPlayer.nNowMotionNum].nNumKey;

	//	if (g_aPlayer.nPatternKey == 0)
	//	{//キーがゼロの時

	//		//攻撃状態解除
	//		g_aPlayer.bATK = false;
	//		g_aPlayer.nCntAllFrame = 0;	//総フレーム数リセット

	//		if (g_aMotionData[g_aPlayer.nNowMotionNum].nLoop == MOTION_LOOP_OFF)
	//		{

	//			//モーションの設定
	//			SetMotisonPlayer(PLAYERMOTION_DEF);
	//		}
	//		else
	//		{
	//			//モーションの設定
	//			SetMotisonPlayer(g_aPlayer.nNowMotionNum);
	//		}

	//	}
	//	else
	//	{
	//		//モーションの設定
	//		SetMotisonPlayer(g_aPlayer.nNowMotionNum);
	//	}

	//}

	for (int nCntParts = 0; nCntParts < g_aPlayer.nPartsNum; nCntParts++)
	{//パーツ分繰り返す

	 //次のキー
		int nNextKey = (g_aPlayer.nPatternKey + 1) % g_aMotionData[g_aPlayer.nNowMotionNum].nNumKey;
		int nnn;

		if (g_aPlayer.nPatternKey == g_aMotionData[g_aPlayer.nNowMotionNum].nNumKey - 1 && g_aMotionData[g_aPlayer.nNowMotionNum].nLoop == MOTION_LOOP_OFF)
		{//ループしないとき

		 //nNextKey = g_aMotionData[g_aPlayer.nNowMotionNum].nNumKey - 1;
		}

		if (g_aPlayer.nPatternKey == g_aMotionData[g_aPlayer.nNowMotionNum].nNumKey - 1 && g_aMotionData[g_aPlayer.nNowMotionNum].nLoop == MOTION_LOOP_ON)
		{//ループの時

			nnn = g_aMotionData[g_aPlayer.nNowMotionNum].nNumKey - 1;
		}

		//前回と次のキーの差分取得
		float rotDiffX = g_aMotionData[g_aPlayer.nNowMotionNum].aKey[nNextKey].aParts[nCntParts].rot.x -
			g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rot.x;

		float rotDiffY = g_aMotionData[g_aPlayer.nNowMotionNum].aKey[nNextKey].aParts[nCntParts].rot.y -
			g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rot.y;

		float rotDiffZ = g_aMotionData[g_aPlayer.nNowMotionNum].aKey[nNextKey].aParts[nCntParts].rot.z -
			g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rot.z;

		//パーツの向きを設定
		g_aPlayer.aModel[nCntParts].rot.x =
			g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rot.x +
			rotDiffX *
			(
			(float)g_aPlayer.nCntFrame /
				(float)g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].nFrame
				);

		g_aPlayer.aModel[nCntParts].rot.y =
			g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rot.y +
			rotDiffY *
			(
			(float)g_aPlayer.nCntFrame /
				(float)g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].nFrame
				);

		g_aPlayer.aModel[nCntParts].rot.z =
			g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].aParts[nCntParts].rot.z +
			rotDiffZ *
			(
			(float)g_aPlayer.nCntFrame /
				(float)g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].nFrame
				);

		//角度の正規化
		g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.x = RotNormalize(g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.x);
		g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.y = RotNormalize(g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.y);
		g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.z = RotNormalize(g_aPlayer.aModel[g_aPlayer.nNowMotionNum].rot.z);

	}

	//フレームのカウントを加算
	g_aPlayer.nCntFrame++;
	g_aPlayer.nCntAllFrame++;

	if (g_aPlayer.nCntFrame >= g_aMotionData[g_aPlayer.nNowMotionNum].aKey[g_aPlayer.nPatternKey].nFrame)
	{//フレームのカウントがフレーム数に達したら

	 //フレームのカウントをゼロに戻す
		g_aPlayer.nCntFrame = 0;

		//パターンNO.更新
		g_aPlayer.nPatternKey = (g_aPlayer.nPatternKey + 1) % g_aMotionData[g_aPlayer.nNowMotionNum].nNumKey;

		if (g_aPlayer.nPatternKey == 0)
		{//キーがゼロの時

			//攻撃状態解除
			g_aPlayer.bATK = false;
			g_aPlayer.nCntAllFrame = 0;	//総フレーム数リセット

			if (g_aMotionData[g_aPlayer.nNowMotionNum].nLoop == MOTION_LOOP_OFF)
			{
				//モーションの設定
				SetMotisonPlayer(PLAYERMOTION_DEF);
			}
			else
			{
				//モーションの設定
				SetMotisonPlayer(g_aPlayer.nNowMotionNum);
			}
		}
	}
}

//==================================================================================
//プレイヤーの描画処理
//==================================================================================
void DrawPlayer(void)
{


	//デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = GetDevice();

	D3DXMATRIX mtxRot, mtxTrans;	//計算用マトリックス宣言
	D3DMATERIAL9 matDef;			//現在のマテリアル保存用
	D3DXMATERIAL *pMat;				//マテリアルデータへのポインタ
	D3DXMATRIX mtxnParent;			//親の計算用マトリックス

	if (g_aPlayer.bDisp == true && g_aPlayer.bUse == true)
	{//使用していたら

	 //ワールドマトリックスの初期化
		D3DXMatrixIdentity(&g_aPlayer.mtxWorld);

		//向きを反映する
		D3DXMatrixRotationYawPitchRoll(&mtxRot, g_aPlayer.rot.y, g_aPlayer.rot.x, g_aPlayer.rot.z);
		D3DXMatrixMultiply(&g_aPlayer.mtxWorld, &g_aPlayer.mtxWorld, &mtxRot);

		//位置を反映する
		D3DXMatrixTranslation(&mtxTrans, g_aPlayer.pos.x, g_aPlayer.pos.y, g_aPlayer.pos.z);
		D3DXMatrixMultiply(&g_aPlayer.mtxWorld, &g_aPlayer.mtxWorld, &mtxTrans);

		//ワールドマトリックスの設定
		pDevice->SetTransform(D3DTS_WORLD, &g_aPlayer.mtxWorld);

		//現在のマテリアルを取得
		pDevice->GetMaterial(&matDef);

		for (int nCount = 0; nCount < g_aPlayer.nPartsNum; nCount++)
		{

			//ワールドマトリックスの初期化
			D3DXMatrixIdentity(&g_aPlayer.aModel[nCount].mtxWorld);

			//向きを反映する
			D3DXMatrixRotationYawPitchRoll(&mtxRot, g_aPlayer.aModel[nCount].rot.y, g_aPlayer.aModel[nCount].rot.x, g_aPlayer.aModel[nCount].rot.z);
			D3DXMatrixMultiply(&g_aPlayer.aModel[nCount].mtxWorld, &g_aPlayer.aModel[nCount].mtxWorld, &mtxRot);

			//位置を反映する
			D3DXMatrixTranslation(&mtxTrans, g_aPlayer.aModel[nCount].pos.x, g_aPlayer.aModel[nCount].pos.y, g_aPlayer.aModel[nCount].pos.z);
			D3DXMatrixMultiply(&g_aPlayer.aModel[nCount].mtxWorld, &g_aPlayer.aModel[nCount].mtxWorld, &mtxTrans);


			if (g_aPlayer.aModel[nCount].nParent == -1)
			{//NULLの場合,親

			 //プレイヤーの向きを反映する
				mtxnParent = g_aPlayer.mtxWorld;
			}
			else
			{//パーツ

			 //親の向きを反映する
				mtxnParent = g_aPlayer.aModel[g_aPlayer.aModel[nCount].nParent].mtxWorld;
			}

			//自分のやつに親のワールドマトリックスを掛け算
			D3DXMatrixMultiply(&g_aPlayer.aModel[nCount].mtxWorld, &g_aPlayer.aModel[nCount].mtxWorld, &mtxnParent);

			//ワールドマトリックスの設定
			pDevice->SetTransform(D3DTS_WORLD, &g_aPlayer.aModel[nCount].mtxWorld);

			//マテリアルデータへのポインタを取得
			pMat = (D3DXMATERIAL*)g_aPlayer.aModel[nCount].pBuffMat->GetBufferPointer();

			if (g_aPlayer.aModel[nCount].bUse == true)
			{//パーツが使用されていたら

			 //頂点数分繰り返し
				for (int nCntMat = 0; nCntMat < (int)g_aPlayer.aModel[nCount].dwNumMat; nCntMat++)
				{

					//マテリアルの設定
					pDevice->SetMaterial(&pMat[nCntMat].MatD3D);

					//テクスチャの設定
					pDevice->SetTexture(0, g_aPlayer.aModel[nCount].pTexture[nCntMat]);

					//プレイヤー(パーツ)の描画
					g_aPlayer.aModel[nCount].pMesh->DrawSubset(nCntMat);

				}

			}
		}

		//保存していたマテリアルを戻す
		pDevice->SetMaterial(&matDef);
	}

}

//==================================================================================
//プレイヤーの情報取得
//==================================================================================
Player *GetPlayer(void)
{
	return &g_aPlayer;
}

//==================================================================================
//プレイヤーの設定処理
//==================================================================================
void SetPlayer(void)
{

	//デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = GetDevice();

	for (int nCntParts = 0; nCntParts < g_aPlayer.nPartsNum; nCntParts++)
	{//パーツ分繰り返す

	 //Xファイルの読み込み
		D3DXLoadMeshFromX(&g_aPlayer.aModel[nCntParts].acFilename[0],
			D3DXMESH_SYSTEMMEM,
			pDevice,
			NULL,
			&g_aPlayer.aModel[nCntParts].pBuffMat,
			NULL,
			&g_aPlayer.aModel[nCntParts].dwNumMat,
			&g_aPlayer.aModel[nCntParts].pMesh);

		D3DXMATERIAL *pMat;		//マテリアルデータへのポインタ

								//マテリアルデータへのポインタを取得
		pMat = (D3DXMATERIAL*)g_aPlayer.aModel[nCntParts].pBuffMat->GetBufferPointer();

		//頂点数分繰り返し
		for (int nCntMat = 0; nCntMat < (int)g_aPlayer.aModel[nCntParts].dwNumMat; nCntMat++)
		{
			//マテリアルのデータ取得
			g_aPlayer.aModel[nCntParts].pMatData[nCntMat] = pMat[nCntMat];

			if (pMat[nCntMat].pTextureFilename != NULL)
			{//ファイルが存在する

			 //テクスチャの読み込み
				D3DXCreateTextureFromFile(pDevice,
					pMat[nCntMat].pTextureFilename,
					&g_aPlayer.aModel[nCntParts].pTexture[nCntMat]);
			}
		}

		//パーツを使用状態
		g_aPlayer.aModel[nCntParts].bUse = true;

		//モデルの全頂点チェック
		CheckVtx(g_aPlayer.aModel[nCntParts].rot.y, &g_aPlayer.aModel[nCntParts].vtxMax, &g_aPlayer.aModel[nCntParts].vtxMin, g_aPlayer.aModel[nCntParts].pMesh, g_aPlayer.aModel[nCntParts].pVtxBuff);
	}

	//影の設定
	g_aPlayer.nIdxShadow = SetShadow(g_aPlayer.fRadius * 0.5f, g_aPlayer.fRadius * 0.5f);
	SetPositionShadow(g_aPlayer.nIdxShadow, g_aPlayer.pos);

	g_aaaaa = SetShadow(g_aPlayer.fRadius * 0.5f, g_aPlayer.fRadius * 0.5f);
	SetPositionShadow(g_aaaaa, g_aPlayer.pos);

	g_bbbbb = SetShadow(g_aPlayer.fRadius * 0.5f, g_aPlayer.fRadius * 0.5f);
	SetPositionShadow(g_bbbbb, g_aPlayer.pos);

	//アイコンの設定
	g_aPlayer.nIdxIcon = SetIcon(MINIMAP_ICON_PLAYER, 80.0f);
	UpdatePositionIcon(g_aPlayer.nIdxIcon, g_aPlayer.pos);

	//セリフをセット
	//g_aPlayer.nIdxSerif = SetSerif(25.0f, 25.0f, 100, SERIFSTATE_DISPATCH, { g_aPlayer.pos.x, g_aPlayer.pos.y + 150.0f, g_aPlayer.pos.z });
	//SetPositionSerif(g_aPlayer.nIdxSerif, g_aPlayer.pos);
}

//==================================================================================
//絶対マトリックスの取得
//==================================================================================
D3DXMATRIX GetParentMatrix(int nIdxParts)
{
	//デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = GetDevice();
	D3DXMATRIX mtxRot, mtxTrans;	//計算用マトリックス宣言
	D3DXMATRIX mtxnParent;			//親の計算用マトリックス

									//ワールドマトリックスの初期化
	D3DXMatrixIdentity(&g_aPlayer.mtxWorld);

	//向きを反映する
	D3DXMatrixRotationYawPitchRoll(&mtxRot, g_aPlayer.rot.y, g_aPlayer.rot.x, g_aPlayer.rot.z);
	D3DXMatrixMultiply(&g_aPlayer.mtxWorld, &g_aPlayer.mtxWorld, &mtxRot);

	//位置を反映する
	D3DXMatrixTranslation(&mtxTrans, g_aPlayer.pos.x, g_aPlayer.pos.y, g_aPlayer.pos.z);
	D3DXMatrixMultiply(&g_aPlayer.mtxWorld, &g_aPlayer.mtxWorld, &mtxTrans);

	//ワールドマトリックスの設定
	pDevice->SetTransform(D3DTS_WORLD, &g_aPlayer.mtxWorld);

	for (int nCount = 0; nCount < g_aPlayer.nPartsNum; nCount++)
	{
		//ワールドマトリックスの初期化
		D3DXMatrixIdentity(&g_aPlayer.aModel[nCount].mtxWorld);

		//向きを反映する
		D3DXMatrixRotationYawPitchRoll(&mtxRot, g_aPlayer.aModel[nCount].rot.y, g_aPlayer.aModel[nCount].rot.x, g_aPlayer.aModel[nCount].rot.z);
		D3DXMatrixMultiply(&g_aPlayer.aModel[nCount].mtxWorld, &g_aPlayer.aModel[nCount].mtxWorld, &mtxRot);

		//位置を反映する
		D3DXMatrixTranslation(&mtxTrans, g_aPlayer.aModel[nCount].pos.x, g_aPlayer.aModel[nCount].pos.y, g_aPlayer.aModel[nCount].pos.z);
		D3DXMatrixMultiply(&g_aPlayer.aModel[nCount].mtxWorld, &g_aPlayer.aModel[nCount].mtxWorld, &mtxTrans);


		if (g_aPlayer.aModel[nCount].nParent == -1)
		{//NULLの場合,親

		 //プレイヤーの向きを反映する
			mtxnParent = g_aPlayer.mtxWorld;
		}
		else
		{//パーツ

		 //親の向きを反映する
			mtxnParent = g_aPlayer.aModel[g_aPlayer.aModel[nCount].nParent].mtxWorld;
		}

		//自分のやつに親のワールドマトリックスを掛け算
		D3DXMatrixMultiply(&g_aPlayer.aModel[nCount].mtxWorld, &g_aPlayer.aModel[nCount].mtxWorld, &mtxnParent);

		//ワールドマトリックスの設定
		pDevice->SetTransform(D3DTS_WORLD, &g_aPlayer.aModel[nCount].mtxWorld);
	}

	return g_aPlayer.aModel[nIdxParts].mtxWorld;
}

//==================================================================================
//プレイヤーの読み込み処理
//==================================================================================
void ReadSetPlayer(void)
{
	FILE *pFile = NULL;	//ファイルポインタを宣言

						//ファイルを開く
	pFile = fopen(PLAYER_TXT, "r");

	if (pFile != NULL)
	{//ファイルが開けた場合

		char aComment[MAX_COMMENT];	//コメント、確認等

		int nCntSetParts = 0;
		int nCntFileName = 0;

		while (1)
		{//END_SCRIPTが来るまで繰り返す

		 //文字列の読み込み
			fscanf(pFile, "%s", &aComment[0]);

			//モデル数の設定
			if (strcmp(aComment, "NUM_MODEL") == 0)
			{//NUM_MODELがきたら

				fscanf(pFile, "%s", &aComment[0]);	//=の分
				fscanf(pFile, "%d", &g_aPlayer.nPartsNum);	//モデル数
			}

			while (nCntFileName != g_aPlayer.nPartsNum)
			{//モデルの数分読み込むまで繰り返し

			 //文字列の読み込み
				fscanf(pFile, "%s", &aComment[0]);

				//モデル名の設定
				if (strcmp(aComment, "MODEL_FILENAME") == 0)
				{//NUM_MODELがきたら

					fscanf(pFile, "%s", &aComment[0]);	//=の分
					fscanf(pFile, "%s", &g_aPlayer.aModel[nCntFileName].acFilename[0]);	//ファイル名
					nCntFileName++;	//ファイル数加算
				}
			}

			//各パーツの設定
			if (strcmp(aComment, "CHARACTERSET") == 0)
			{//キャラクター情報の読み込みを開始

				while (strcmp(aComment, "END_CHARACTERSET") != 0)
				{//END_CHARACTERSETが来るまで繰り返し

					fscanf(pFile, "%s", &aComment[0]);	//確認する

					if (strcmp(aComment, "PARTSSET") == 0)
					{//PARTSSETでパーツ情報の読み込み開始

						while (strcmp(aComment, "END_PARTSSET") != 0)
						{//END_PARTSSETが来るまで繰り返す

							fscanf(pFile, "%s", &aComment[0]);	//確認する

							if (strcmp(aComment, "INDEX") == 0)
							{//INDEXが来たらモデル番号読み込み

								fscanf(pFile, "%s", &aComment[0]);		//=の分
								fscanf(pFile, "%d", &g_aPlayer.aModel[nCntSetParts].nType);	//モデル種類の列挙

							}

							if (strcmp(aComment, "PARENT") == 0)
							{//PARENTが来たら親の番号読み込み

								fscanf(pFile, "%s", &aComment[0]);		//=の分
								fscanf(pFile, "%d", &g_aPlayer.aModel[nCntSetParts].nParent);	//親の番号

							}

							if (strcmp(aComment, "POS") == 0)
							{//POSが来たら位置読み込み

								fscanf(pFile, "%s", &aComment[0]);		//=の分
								fscanf(pFile, "%f", &g_aPlayer.aModel[nCntSetParts].pos.x);	//X座標
								fscanf(pFile, "%f", &g_aPlayer.aModel[nCntSetParts].pos.y);	//Y座標
								fscanf(pFile, "%f", &g_aPlayer.aModel[nCntSetParts].pos.z);	//Z座標

																							//元の位置割り当て
								g_aPlayer.aModel[nCntSetParts].posOrigin = g_aPlayer.aModel[nCntSetParts].pos;

							}

							if (strcmp(aComment, "ROT") == 0)
							{//ROTが来たら向き読み込み

								fscanf(pFile, "%s", &aComment[0]);		//=の分
								fscanf(pFile, "%f", &g_aPlayer.aModel[nCntSetParts].rot.x);	//Xの角度
								fscanf(pFile, "%f", &g_aPlayer.aModel[nCntSetParts].rot.y);	//Yの角度
								fscanf(pFile, "%f", &g_aPlayer.aModel[nCntSetParts].rot.z);	//Zの角度

							}

							if (strcmp(aComment, "WEAPON") == 0)
							{//WEAPONが来たら武器かどうか読み込み

								fscanf(pFile, "%s", &aComment[0]);		//=の分

							}

						}//END_PARTSSETのかっこ

						nCntSetParts++;	//パーツのカウントを加算
					}

				}//END_CHARACTERSETのかっこ

			}

			if (strcmp(aComment, "END_SCRIPT") == 0)
			{//終了文字でループを抜ける

				break;
			}
		}

		//ファイルを閉じる
		fclose(pFile);
	}

	//プレイヤーの配置
	SetPlayer();

}

//==================================================================================
//プレイヤーの読み込み処理
//==================================================================================
void ReadSetMotionPlayer(void)
{

	FILE *pFile = NULL;	//ファイルポインタを宣言

	char aComment[MAX_COMMENT];	//コメント用
	int nCntMotion = 0, nCntKey = 0, nCntParts = 0;

	//ファイルを開く
	pFile = fopen("data\\TEXT\\motion_set_player.txt", "r");

	if (pFile != NULL)
	{//ファイルが開けた場合

		while (1)
		{//END_SCRIPTが来るまで繰り返す

		 //文字列の読み込み
			fscanf(pFile, "%s", &aComment[0]);

			//==================================================
			//各モーションの設定
			//==================================================
			if (strcmp(aComment, "MOTIONSET") == 0)
			{//モーション情報の読み込みを開始

				while (strcmp(aComment, "END_MOTIONSET") != 0)
				{//END_MOTIONSETが来るまで繰り返し

					fscanf(pFile, "%s", &aComment[0]);	//確認する

					if (strcmp(aComment, "LOOP") == 0)
					{//LOOPが来たらループON/OFF読み込み

						fscanf(pFile, "%s", &aComment[0]);		//=の分
						fscanf(pFile, "%d", &g_aMotionData[nCntMotion].nLoop);	//ループ0か1

					}

					if (strcmp(aComment, "NUM_KEY") == 0)
					{//NUM_KEYが来たらキー数読み込み

						fscanf(pFile, "%s", &aComment[0]);		//=の分
						fscanf(pFile, "%d", &g_aMotionData[nCntMotion].nNumKey);	//キー数

					}

					//==================================================
					//各キーの設定
					//==================================================
					if (strcmp(aComment, "KEYSET") == 0)
					{//KEYSETでキー情報の読み込み開始

						while (strcmp(aComment, "END_KEYSET") != 0)
						{//END_KEYSETが来るまで繰り返し

							fscanf(pFile, "%s", &aComment[0]);	//確認する

							if (strcmp(aComment, "FRAME") == 0)
							{//FRAMEが来たら再生フレーム数読み込み

								fscanf(pFile, "%s", &aComment[0]);		//=の分
								fscanf(pFile, "%d", &g_aMotionData[nCntMotion].aKey[nCntKey].nFrame);	//再生フレーム

							}

							//==================================================
							//パーツの設定
							//==================================================
							if (strcmp(aComment, "PARTS") == 0)
							{//PARTSでパーツ情報の読み込み開始

								while (strcmp(aComment, "END_PARTS") != 0)
								{//END_PARTSが来るまで繰り返し

									fscanf(pFile, "%s", &aComment[0]);	//確認する

									if (strcmp(aComment, "POS") == 0)
									{//POSが来たら位置読み込み

										fscanf(pFile, "%s", &aComment[0]);		//=の分
										fscanf(pFile, "%f", &g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].pos.x);	//X座標
										fscanf(pFile, "%f", &g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].pos.y);	//Y座標
										fscanf(pFile, "%f", &g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].pos.z);	//Z座標
									}

									if (strcmp(aComment, "ROT") == 0)
									{//ROTが来たら角度読み込み

										fscanf(pFile, "%s", &aComment[0]);		//=の分
										fscanf(pFile, "%f", &g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].rot.x);	//X角度
										fscanf(pFile, "%f", &g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].rot.y);	//Y角度
										fscanf(pFile, "%f", &g_aMotionData[nCntMotion].aKey[nCntKey].aParts[nCntParts].rot.z);	//Z角度
									}

								}//END_PARTSのかっこ

								nCntParts++;	//パーツのカウント加算
							}


						}//END_KEYSETのかっこ

						nCntParts = 0;	//パーツのカウントリセット
						nCntKey++;	//キーのカウント加算
					}

				}//END_MOTIONSETのかっこ

				nCntKey = 0;	//キーのカウントリセット
				nCntMotion++;	//モーションのカウント加算

			}


			if (strcmp(aComment, "END_SCRIPT") == 0)
			{//終了文字でループを抜ける

				break;
			}
		}

		//ファイルを閉じる
		fclose(pFile);
	}
}

//==================================================================================
//チュートリアルの更新処理
//==================================================================================
void UpdateTutorialPlayer(void)
{
	//カメラの情報取得
	Camera *pCamera = GetCamera();

	if (g_aPlayer.bUse == true)
	{//使用していたら

		//過去の位置保存
		g_aPlayer.posOld = g_aPlayer.pos;

		for (int nCntParts = 0; nCntParts < g_aPlayer.nPartsNum; nCntParts++)
		{//パーツ分繰り返す

			//パーツごとのマトリックス取得
			D3DXMATRIX mtxParts = GetParentMatrix(nCntParts);

			g_aPlayer.aModel[nCntParts].OldmtxWorld = mtxParts;
		}


		//プレイヤーの操作
		ControllTutorialPlayer();

		//隊列の位置更新
		CalFormationPosPlayer();

		//攻撃処理
		UpdateATKGun();
		UpdateATKPenLight();

		if (g_aPlayer.bMove == true && g_aPlayer.bJump == false)
		{//移動してるとき

			g_aPlayer.nCntWalk++;	//カウント加算

			if (g_aPlayer.nCntWalk > 24)
			{
				g_aPlayer.nCntWalk = 0;

				//歩行パーティクルの設定
				SetParticle(g_aPlayer.pos, PARTICLE_TYPE_WALK);
			}


			if (g_aPlayer.nNowMotionNum != PLAYERMOTION_WALK)
			{
				//モーションの設定
				SetMotisonPlayer(PLAYERMOTION_WALK);
			}

		}
		else if (g_aPlayer.bJump == true)
		{//ジャンプしている

			if (g_aPlayer.nNowMotionNum != PLAYERMOTION_JUMP)
			{
				//モーションの設定
				SetMotisonPlayer(PLAYERMOTION_JUMP);
			}
		}
		else if (g_aPlayer.bATK == true)
		{//攻撃してるとき

			if (g_aPlayer.nNowMotionNum != PLAYERMOTION_ACTION)
			{
				//モーションの設定
				SetMotisonPlayer(PLAYERMOTION_ACTION);
			}
		}
		else
		{//ニュートラルモーション

			if (g_aPlayer.nNowMotionNum != PLAYERMOTION_DEF &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_ACTION &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_DISPATCHL &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_DISPATCHR &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_RETURNL &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_RETURNR)
			{
				//攻撃状態解除
				g_aPlayer.bATK = false;

				//モーションの設定
				SetMotisonPlayer(PLAYERMOTION_DEF);
			}
		}

		//軌跡の情報取得
		ORBIT *pOrbit = GetMeshOrbit();

		//パーツごとのマトリックス取得
		D3DXMATRIX mtxParts = GetParentMatrix(10);

		pOrbit->pMtxparent = &mtxParts;

		//モーションの更新
		UpdateMotionPlayer();

		//キャラクターとの当たり判定
		CollisionCharPlayer();

		//座標制限
		LimitPosPlayer();

		//影の位置更新
		SetPositionShadow(g_aPlayer.nIdxShadow, g_aPlayer.pos);

		//アイコンの位置更新
		UpdatePositionIcon(g_aPlayer.nIdxIcon, g_aPlayer.pos);

	}

	//状態更新
	UpdateStatePlayer();

}

//==================================================================================
//チュートリアルの操作
//==================================================================================
void ControllTutorialPlayer(void)
{
	//カメラの情報取得
	Camera *pCamera = GetCamera();

	//エディットの情報取得
	Edit  *pEdit = GetEdit();

	//ターゲットの情報取得
	DISPATCH *pDispatch = GetDispatch();

	//チュートリアルの情報取得
	Tutorial *pTutorial = GetTutorial();

	if (GetGameState() == GAMESTATE_NONE && pDispatch->bUse == false)
	{//ターゲット中以外

		//========================================================================
		//移動のステップ以上で操作可能
		//========================================================================
		if (pTutorial->nStep >= TUTORIAL_STEP_MOVE && pTutorial->nStep != TUTORIAL_STEP_MORS)
		{
			if (g_aPlayer.bATK == false &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_DISPATCHL &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_DISPATCHR &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_RETURNL &&
				g_aPlayer.nNowMotionNum != PLAYERMOTION_RETURNR)
			{//ガン発動中は強制キャンセル

				if (GetKeyboardPress(DIK_A) == true || XGetStickPressL(BUTTON_LX, 0) < 0)
				{//←キーが押された,左移動

					if (GetKeyboardPress(DIK_W) == true || YGetStickPressL(BUTTON_LY, 0) > 0)
					{//A+W,左上移動

						g_aPlayer.move.x += sinf(-D3DX_PI * MOVE_LRDW + pCamera->rot.y) * MOVE;
						g_aPlayer.move.z += cosf(-D3DX_PI * MOVE_LRDW + pCamera->rot.y) * MOVE;
						g_aPlayer.fRotDest = D3DX_PI * MOVE_LRUP + pCamera->rot.y;
					}
					else if (GetKeyboardPress(DIK_S) == true || YGetStickPressL(BUTTON_LY, 0) < 0)
					{//A+S,左下移動

						g_aPlayer.move.x += sinf(-D3DX_PI * MOVE_LRUP + pCamera->rot.y) * MOVE;
						g_aPlayer.move.z += cosf(-D3DX_PI * MOVE_LRUP + pCamera->rot.y) * MOVE;
						g_aPlayer.fRotDest = D3DX_PI * MOVE_LRDW + pCamera->rot.y;
					}
					else
					{//A,左移動

						g_aPlayer.move.x += sinf(-D3DX_PI * MOVE_LR + pCamera->rot.y) * MOVE;
						g_aPlayer.move.z += cosf(-D3DX_PI * MOVE_LR + pCamera->rot.y) * MOVE;
						g_aPlayer.fRotDest = D3DX_PI * MOVE_LR + pCamera->rot.y;
					}

					g_aPlayer.bMove = true;

					//左移動完了
					pTutorial->aControl.bLMove = true;
				}
				else if (GetKeyboardPress(DIK_D) == true || XGetStickPressL(BUTTON_LX, 0) > 0)
				{//Dキーが押された,右移動

					if (GetKeyboardPress(DIK_W) == true || YGetStickPressL(BUTTON_LY, 0) > 0)
					{//D+W,右上移動

						g_aPlayer.move.x += sinf(D3DX_PI * MOVE_LRDW + pCamera->rot.y) * MOVE;
						g_aPlayer.move.z += cosf(D3DX_PI * MOVE_LRDW + pCamera->rot.y) * MOVE;
						g_aPlayer.fRotDest = -D3DX_PI * MOVE_LRUP + pCamera->rot.y;
					}
					else if (GetKeyboardPress(DIK_S) == true || YGetStickPressL(BUTTON_LY, 0) < 0)
					{//D+S,右下移動

						g_aPlayer.move.x += sinf(D3DX_PI * MOVE_LRUP + pCamera->rot.y) * MOVE;
						g_aPlayer.move.z += cosf(D3DX_PI * MOVE_LRUP + pCamera->rot.y) * MOVE;
						g_aPlayer.fRotDest = -D3DX_PI * MOVE_LRDW + pCamera->rot.y;
					}
					else
					{//D,右移動

						g_aPlayer.move.x += sinf(D3DX_PI * MOVE_LR + pCamera->rot.y) * MOVE;
						g_aPlayer.move.z += cosf(D3DX_PI * MOVE_LR + pCamera->rot.y) * MOVE;
						g_aPlayer.fRotDest = -D3DX_PI * MOVE_LR + pCamera->rot.y;
					}

					//右移動完了
					pTutorial->aControl.bRMove = true;

					g_aPlayer.bMove = true;
				}
				else if (GetKeyboardPress(DIK_W) == true || YGetStickPressL(BUTTON_LY, 0) > 0)
				{//Wが押された、奥移動

					g_aPlayer.move.x += sinf(pCamera->rot.y) * MOVE;
					g_aPlayer.move.z += cosf(pCamera->rot.y) * MOVE;
					g_aPlayer.fRotDest = D3DX_PI + pCamera->rot.y;
					g_aPlayer.bMove = true;

					//奥移動完了
					pTutorial->aControl.bUPMove = true;

				}
				else if (GetKeyboardPress(DIK_S) == true || YGetStickPressL(BUTTON_LY, 0) < 0)
				{//Sが押された、手前移動

					g_aPlayer.move.x += sinf(D3DX_PI + pCamera->rot.y) * MOVE;
					g_aPlayer.move.z += cosf(D3DX_PI + pCamera->rot.y) * MOVE;
					g_aPlayer.fRotDest = pCamera->rot.y;
					g_aPlayer.bMove = true;

					//手前移動完了
					pTutorial->aControl.bDWMove = true;
				}
				else
				{//なんのキーも押されていない

					if (g_aPlayer.move.x <= 1.0f && g_aPlayer.move.x >= -1.0f ||
						g_aPlayer.move.z <= 1.0f && g_aPlayer.move.z >= -1.0f)
					{
						g_aPlayer.bMove = false;
					}
				}
			}
		}

		//========================================================================
		//派遣のステップ以上で操作可能
		//========================================================================
		if (pTutorial->nStep >= TUTORIAL_STEP_DISPATCH && pTutorial->nStep != TUTORIAL_STEP_MORS)
		{
			if (GetGamepadTrigger(BUTTON_RB, 0) || GetKeyboardTrigger(DIK_RSHIFT) == true)
			{//派遣の使用状況入れ替え

				SetRightDisPatch();
			}
			if (GetGamepadTrigger(BUTTON_LB, 0) || GetKeyboardTrigger(DIK_LSHIFT) == true)
			{//派遣の使用状況入れ替え

				SetLeftDisPatch();
			}
		}

		//========================================================================
		//催眠のステップ以上で操作可能
		//========================================================================
		if (pTutorial->nStep >= TUTORIAL_STEP_HYPNOSIS && pTutorial->nStep != TUTORIAL_STEP_MORS)
		{
			if (g_aPlayer.bJump == false && GetKeyboardTrigger(DIK_L) == true)
			{//Lが押された

				g_aPlayer.bATK = true;
				g_aPlayer.bMove = false;
				g_aPlayer.move.x = 0.0f;
				g_aPlayer.move.z = 0.0f;
			}
		}

		//========================================================================
		//洗脳のステップ以上で操作可能
		//========================================================================
		if (pTutorial->nStep >= TUTORIAL_STEP_SENNOU && pTutorial->nStep != TUTORIAL_STEP_MORS)
		{
			if (g_aPlayer.bATK == false && g_aPlayer.bJump == false && GetKeyboardTrigger(DIK_RETURN) == true ||
				g_aPlayer.bATK == false && g_aPlayer.bJump == false && GetGamepadTrigger(BUTTON_B, 0))
			{//ENTERが押された,,弾発射

				//抱き枕の設定処理
				SetCutepillow(g_aPlayer.pos, g_aPlayer.rot, PILLOWPARENT_PLAYER);
			}
		}
	}

	//現在と目標の差分を求める
	g_aPlayer.fRotDiff = g_aPlayer.fRotDest - g_aPlayer.rot.y;

	//角度の正規化
	g_aPlayer.fRotDiff = RotNormalize(g_aPlayer.fRotDiff);

	//角度の補正をする
	g_aPlayer.rot.y += g_aPlayer.fRotDiff * 0.1f;

	//角度の正規化
	g_aPlayer.rot.y = RotNormalize(g_aPlayer.rot.y);

	//重力処理
	g_aPlayer.move.y -= 1.0f;

	//位置更新
	g_aPlayer.pos += g_aPlayer.move;

	//慣性つける
	g_aPlayer.move.x += (0.0f - g_aPlayer.move.x) * 0.15f;
	g_aPlayer.move.z += (0.0f - g_aPlayer.move.z) * 0.15f;
}
